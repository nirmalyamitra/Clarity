import * as Protocol from "./protocol";
export interface IProtocolCodegenOptions {
    clientModuleName?: string;
    indent?: string;
}
/**
 * Generate Typescript interface to use with the DebuggingProtocol#domains(protocol) method.
 */
export default class ProtocolCodegen {
    private indent;
    private clientModuleName;
    private code;
    private indentStack;
    private refs;
    constructor(options: IProtocolCodegenOptions);
    readonly currentIndent: string;
    generate(protocol: Protocol.IProtocol): string;
    protected generatorMissingRefs(domainName: string, refs: Map<string, boolean>): void;
    protected getRefs(domainName: string): Map<string, boolean>;
    protected gatherRefs(domain: Protocol.IDomain): void;
    protected gatherRefsFromDescs(descs: Protocol.TypeRefOrDescriptor[], refs: Map<string, boolean>): void;
    protected gatherRefsFromDesc(desc: Protocol.TypeRefOrDescriptor, refs: Map<string, boolean>): void;
    protected appendProtocolVersionComment(version?: Protocol.IVersion): void;
    protected appendClientImport(): void;
    protected appendDomainClass(domainName: string, cb: () => void): void;
    protected generateDomainTypeNamespace(domainName: string, cb: () => void): void;
    protected appendEventMember(event: Protocol.IEvent, domainName: string): void;
    protected appendClientMember(): void;
    protected appendDomainConstructor(): void;
    protected appendCommandMethod(command: Protocol.ICommand, domainName: string): void;
    protected appendEventAccessors(event: Protocol.IEvent, domainName: string): void;
    protected appendType(type: Protocol.Type): void;
    protected appendEventParametersType(event: Protocol.IEvent): void;
    protected appendEventHandlerType(event: Protocol.IEvent): void;
    protected block(cb: () => void): void;
    protected append(line: string): void;
    protected generateProperty(desc: Protocol.NamedDescriptor): void;
    protected appendComment(obj: {
        description?: string;
    }): void;
    protected appendCommandTypes(command: Protocol.ICommand): void;
    protected returnTypeName(name: string, domainName?: string): string;
    protected parametersTypeName(name: string, domainName?: string): string;
    protected handlerTypeName(name: string, domainName?: string): string;
    protected generateObjectTypeAlias(name: string, props: Protocol.NamedDescriptor[]): void;
    protected namedTypeString(desc: Protocol.NamedDescriptor): string;
    protected typeString(desc: Protocol.TypeRefOrDescriptor, isArray?: boolean): string;
}
